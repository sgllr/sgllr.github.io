[{"title":"各种排序算法总结","url":"/2020/09/08/sorting_algorithms/","content":"<h2 id=\"各种排序算法总结\"><a href=\"#各种排序算法总结\" class=\"headerlink\" title=\"各种排序算法总结\"></a>各种排序算法总结</h2><p>本文主要是为了总结各种算法的写法，复杂度，以及稳定性分析，主要是个人做个记录，如果有任何需要修改或优化的地方欢迎在评论区留言哦！</p>\n<h3 id=\"排序算法时间、空间、稳定性表\"><a href=\"#排序算法时间、空间、稳定性表\" class=\"headerlink\" title=\"排序算法时间、空间、稳定性表\"></a>排序算法时间、空间、稳定性表</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>最好</th>\n<th>最坏</th>\n<th>平均</th>\n<th>空间</th>\n<th style=\"text-align:center\">稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td>O(n)</td>\n<td>O(n<sup>2</sup>)</td>\n<td>O(n<sup>2</sup>)</td>\n<td>O(1)</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>O(n<sup>2</sup>)</td>\n<td>O(n<sup>2</sup>)</td>\n<td>O(n<sup>2</sup>)</td>\n<td>O(1)</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>O(n)</td>\n<td>O(n<sup>2</sup>)</td>\n<td>O(n<sup>2</sup>)</td>\n<td>O(1)</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>O(nlog n)</td>\n<td>O(n<sup>2</sup>)</td>\n<td>O(nlog n)</td>\n<td>O(log n)-O(n)</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>O(nlog n)</td>\n<td>O(nlog n)</td>\n<td>O(nlog n)</td>\n<td>O(n)</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>O(n^1.3)</td>\n<td>O(n<sup>2</sup>)</td>\n<td>O(nlog n)-O(n<sup>2</sup>)</td>\n<td>O(1)</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td>计数排序</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>O(nk)</td>\n<td>O(nk)</td>\n<td>O(nk)</td>\n<td>O(n+k)</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td>桶排序</td>\n<td>O(n)</td>\n<td>O(n)</td>\n<td>O(n)</td>\n<td>O(n+m)</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlog n)</td>\n<td>O(nlog n)</td>\n<td>O(nlog n)</td>\n<td>O(1)</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>注：稳定性是指：假定在待排序的记录序列中，存在多个具有<strong>相同的关键字</strong>的记录，若经过排序，这些记录的<strong>相对次序</strong>保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>\n<a id=\"more\"></a>\n<h2 id=\"冒泡排序-Bubble-Sort\"><a href=\"#冒泡排序-Bubble-Sort\" class=\"headerlink\" title=\"冒泡排序 Bubble Sort\"></a>冒泡排序 Bubble Sort</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>作为本人踏入算法殿堂学习的第一个排序算法，冒泡排序可以算是经典算法之一了，它的基本思想是：<em><u>两个数比较大小，较大的数下沉，较小的数冒起来</u></em>。</p>\n</blockquote>\n<ol>\n<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>\n</li>\n<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>\n</li>\n<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>\n</li>\n<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>\n</li>\n</ol>\n<h3 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h3><p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif\" alt=\"冒泡排序\"></p>\n<h3 id=\"Python-算法实现\"><a href=\"#Python-算法实现\" class=\"headerlink\" title=\"Python 算法实现\"></a>Python 算法实现</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble</span>(<span class=\"params\">array</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(array)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(array)-i-<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> array[j] &gt; array[j+<span class=\"number\">1</span>]:  <span class=\"comment\">#判断大小，大的排在后面</span></span><br><span class=\"line\">                array[j], array[j+<span class=\"number\">1</span>] = array[j+<span class=\"number\">1</span>], array[j]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>平均时间复杂度 O(n<sup>2</sup>)</p>\n<h2 id=\"选择排序-Selection-Sort\"><a href=\"#选择排序-Selection-Sort\" class=\"headerlink\" title=\"选择排序 Selection Sort\"></a>选择排序 Selection Sort</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>\n</li>\n<li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>\n</li>\n<li><p>重复第二步，直到所有元素均排序完毕。</p>\n</li>\n</ol>\n<h3 id=\"图示-1\"><a href=\"#图示-1\" class=\"headerlink\" title=\"图示\"></a>图示</h3><p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif\" alt=\"选择排序\"></p>\n<h3 id=\"Python-算法实现-1\"><a href=\"#Python-算法实现-1\" class=\"headerlink\" title=\"Python 算法实现\"></a>Python 算法实现</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">selection</span>(<span class=\"params\">array</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(array)):</span><br><span class=\"line\">        low = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i+<span class=\"number\">1</span>, <span class=\"built_in\">len</span>(array)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> array[j] &lt; array[low]:</span><br><span class=\"line\">                low = j</span><br><span class=\"line\">        array[i], array[low] = array[low], array[i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>平均时间复杂度 O(n<sup>2</sup>)</p>\n<h2 id=\"插入排序-Insersion-Sort\"><a href=\"#插入排序-Insersion-Sort\" class=\"headerlink\" title=\"插入排序 Insersion Sort\"></a>插入排序 Insersion Sort</h2><h3 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n</blockquote>\n<ol>\n<li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>\n</li>\n<li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>\n</li>\n</ol>\n<h3 id=\"图示-2\"><a href=\"#图示-2\" class=\"headerlink\" title=\"图示\"></a>图示</h3><p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif\" alt=\"插入排序\"></p>\n<h3 id=\"Python-算法实现-2\"><a href=\"#Python-算法实现-2\" class=\"headerlink\" title=\"Python 算法实现\"></a>Python 算法实现</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insertion</span>(<span class=\"params\">array</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"built_in\">len</span>(array)):</span><br><span class=\"line\">        val = array[i]</span><br><span class=\"line\">        j = i-<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> val &lt; array[j]:</span><br><span class=\"line\">            array[j+<span class=\"number\">1</span>] = array[j]</span><br><span class=\"line\">            j-=<span class=\"number\">1</span></span><br><span class=\"line\">        array[j+<span class=\"number\">1</span>] = val</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度-2\"><a href=\"#复杂度-2\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>平均时间复杂度 O(n<sup>2</sup>)</p>\n<h2 id=\"快速排序-Quick-Sort\"><a href=\"#快速排序-Quick-Sort\" class=\"headerlink\" title=\"快速排序 Quick Sort\"></a>快速排序 Quick Sort</h2><h3 id=\"概述-3\"><a href=\"#概述-3\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>快速排序的最坏运行情况是 O(n<sup>2</sup>)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>\n</blockquote>\n<ol>\n<li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p>\n</li>\n<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>\n</li>\n<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>\n</li>\n</ol>\n<h3 id=\"图示-3\"><a href=\"#图示-3\" class=\"headerlink\" title=\"图示\"></a>图示</h3><p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif\" alt=\"快速排序\"></p>\n<h3 id=\"Python-算法实现-3\"><a href=\"#Python-算法实现-3\" class=\"headerlink\" title=\"Python 算法实现\"></a>Python 算法实现</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span>(<span class=\"params\">arr, low, high</span>):</span></span><br><span class=\"line\">    pivot = arr[high]</span><br><span class=\"line\">    r = low - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(low, high):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[i] &lt; pivot:</span><br><span class=\"line\">            r += <span class=\"number\">1</span></span><br><span class=\"line\">            arr[r], arr[i] = arr[i], arr[r]</span><br><span class=\"line\">    arr[r+<span class=\"number\">1</span>], arr[high] = arr[high], arr[r+<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r+<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quicksort</span>(<span class=\"params\">arr, left, right</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &gt;= right:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    pivot = partition(arr, left, right)</span><br><span class=\"line\">    quicksort(arr, left, pivot - <span class=\"number\">1</span>)</span><br><span class=\"line\">    quicksort(arr, pivot + <span class=\"number\">1</span>, right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度-3\"><a href=\"#复杂度-3\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>平均时间复杂度 O(nlog n)</p>\n<h2 id=\"归并排序-Merge-Sort\"><a href=\"#归并排序-Merge-Sort\" class=\"headerlink\" title=\"归并排序 Merge Sort\"></a>归并排序 Merge Sort</h2><h3 id=\"概述-4\"><a href=\"#概述-4\" class=\"headerlink\" title=\"概述\"></a>概述</h3><blockquote>\n<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>\n</blockquote>\n<ol>\n<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>\n</li>\n<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>\n</li>\n<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>\n</li>\n<li><p>重复步骤 3 直到某一指针达到序列尾；</p>\n</li>\n<li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p>\n</li>\n</ol>\n<h3 id=\"图示-4\"><a href=\"#图示-4\" class=\"headerlink\" title=\"图示\"></a>图示</h3><p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif\" alt=\"归并排序\"></p>\n<h3 id=\"Python-算法实现-4\"><a href=\"#Python-算法实现-4\" class=\"headerlink\" title=\"Python 算法实现\"></a>Python 算法实现</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span>(<span class=\"params\">array, l, r</span>):</span></span><br><span class=\"line\">    i = j = k = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(l) <span class=\"keyword\">and</span> j &lt; <span class=\"built_in\">len</span>(r):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l[i] &lt; r[j]:</span><br><span class=\"line\">            array[k] = l[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            array[k] = r[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        k += <span class=\"number\">1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(l):</span><br><span class=\"line\">        array[k] = l[i]</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        k += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> j &lt; <span class=\"built_in\">len</span>(r): </span><br><span class=\"line\">        array[k] = r[j]</span><br><span class=\"line\">        j+= <span class=\"number\">1</span></span><br><span class=\"line\">        k+= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> array</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergesort</span>(<span class=\"params\">array</span>):</span></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(array)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array</span><br><span class=\"line\">    left = mergesort(array[:n//<span class=\"number\">2</span>])</span><br><span class=\"line\">    right = mergesort(array[n//<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(array, left, right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度-4\"><a href=\"#复杂度-4\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><p>平均时间复杂度 O(nlog n)</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.runoob.com/w3cnote/sort-algorithm-summary.html\">排序算法总结 | 菜鸟教程</a></p>\n<p><a href=\"https://www.runoob.com/w3cnote/ten-sorting-algorithm.html\">1.0 十大经典排序算法 | 菜鸟教程</a></p>\n<p><a href=\"https://blog.csdn.net/u012501054/article/details/79342580\">排序算法的稳定性及其意义_u012501054的博客-CSDN博客</a></p>\n<p>图片版权所有为菜鸟教程 runoob.com，如有侵权请联系删除。</p>\n","categories":["算法"],"tags":["排序","算法"]},{"title":"测试一下","url":"/2020/12/18/%E5%BC%A0%E9%A1%BA%E7%A3%8A/","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"密码错误！\" data-whm=\"密码错误！\"><div class=\"hbe-input-container\"><input type=\"password\" id=\"hbePass\" placeholder=\"请输入密码...\" /><label>请输入密码...</label><div class=\"bottom-line\"></div></div><script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"a237449fb877d8939a3fe01c68ac1a92af50e464709a18eeb7a3253355c82c30\">1b693c4938223286468132b2f7068bf66587009aeba403a54bfbe367ab2eb6dee8324cd694107ff85065fdfdfd82b652736cc443c336f9aaa5154549112f9fc16f676a982b99f320ad1f024bc02323ba9a32d6b7fb6757943105fa702c93657c</script></div><script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","categories":["测试文档"],"tags":["测试文档"]}]